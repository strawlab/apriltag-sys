/* automatically generated by rust-bindgen */

#![allow(dead_code,non_upper_case_globals,non_camel_case_types,non_snake_case)]

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " Defines a matrix structure for holding double-precision values with"]
#[doc = " data in row-major order (i.e. index = row*ncols + col)."]
#[doc = ""]
#[doc = " nrows and ncols are 1-based counts with the exception that a scalar (non-matrix)"]
#[doc = "   is represented with nrows=0 and/or ncols=0."]
#[repr(C)]
#[derive(Debug)]
pub struct matd_t {
    pub nrows: ::std::os::raw::c_uint,
    pub ncols: ::std::os::raw::c_uint,
    pub data: __IncompleteArrayField<f64>,
}
#[test]
fn bindgen_test_layout_matd_t() {
    assert_eq!(
        ::std::mem::size_of::<matd_t>(),
        8usize,
        concat!("Size of: ", stringify!(matd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<matd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(matd_t))
    );
}
pub type image_u8_t = image_u8;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct image_u8 {
    pub width: i32,
    pub height: i32,
    pub stride: i32,
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_image_u8() {
    assert_eq!(
        ::std::mem::size_of::<image_u8>(),
        24usize,
        concat!("Size of: ", stringify!(image_u8))
    );
    assert_eq!(
        ::std::mem::align_of::<image_u8>(),
        8usize,
        concat!("Alignment of ", stringify!(image_u8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_u8>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_u8),
            "::",
            stringify!(buf)
        )
    );
}
#[doc = " Defines a structure which acts as a resize-able array ala Java's ArrayList."]
pub type zarray_t = zarray;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct zarray {
    pub el_sz: usize,
    pub size: ::std::os::raw::c_int,
    pub alloc: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_zarray() {
    assert_eq!(
        ::std::mem::size_of::<zarray>(),
        24usize,
        concat!("Size of: ", stringify!(zarray))
    );
    assert_eq!(
        ::std::mem::align_of::<zarray>(),
        8usize,
        concat!("Alignment of ", stringify!(zarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).el_sz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(el_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).alloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zarray>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zarray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workerpool {
    _unused: [u8; 0],
}
pub type workerpool_t = workerpool;
pub type timeprofile_t = timeprofile;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct timeprofile {
    pub utime: i64,
    pub stamps: *mut zarray_t,
}
#[test]
fn bindgen_test_layout_timeprofile() {
    assert_eq!(
        ::std::mem::size_of::<timeprofile>(),
        16usize,
        concat!("Size of: ", stringify!(timeprofile))
    );
    assert_eq!(
        ::std::mem::align_of::<timeprofile>(),
        8usize,
        concat!("Alignment of ", stringify!(timeprofile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeprofile>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeprofile>())).stamps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeprofile),
            "::",
            stringify!(stamps)
        )
    );
}
pub type apriltag_family_t = apriltag_family;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct apriltag_family {
    pub ncodes: u32,
    pub codes: *mut u64,
    pub width_at_border: ::std::os::raw::c_int,
    pub total_width: ::std::os::raw::c_int,
    pub reversed_border: bool,
    pub nbits: u32,
    pub bit_x: *mut u32,
    pub bit_y: *mut u32,
    pub h: u32,
    pub name: *mut ::std::os::raw::c_char,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_apriltag_family() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_family>(),
        72usize,
        concat!("Size of: ", stringify!(apriltag_family))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_family>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_family))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).ncodes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(ncodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).codes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(codes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).width_at_border as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(width_at_border)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).total_width as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(total_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).reversed_border as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(reversed_border)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).nbits as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).bit_x as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).bit_y as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(bit_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).h as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_family>())).impl_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_family),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct apriltag_quad_thresh_params {
    pub min_cluster_pixels: ::std::os::raw::c_int,
    pub max_nmaxima: ::std::os::raw::c_int,
    pub critical_rad: f32,
    pub cos_critical_rad: f32,
    pub max_line_fit_mse: f32,
    pub min_white_black_diff: ::std::os::raw::c_int,
    pub deglitch: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apriltag_quad_thresh_params() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_quad_thresh_params>(),
        28usize,
        concat!("Size of: ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_quad_thresh_params>(),
        4usize,
        concat!("Alignment of ", stringify!(apriltag_quad_thresh_params))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).min_cluster_pixels as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_cluster_pixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).max_nmaxima as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_nmaxima)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).critical_rad as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(critical_rad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).cos_critical_rad as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(cos_critical_rad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).max_line_fit_mse as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(max_line_fit_mse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).min_white_black_diff as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(min_white_black_diff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_quad_thresh_params>())).deglitch as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_quad_thresh_params),
            "::",
            stringify!(deglitch)
        )
    );
}
pub type apriltag_detector_t = apriltag_detector;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apriltag_detector {
    #[doc = ""]
    pub nthreads: ::std::os::raw::c_int,
    pub quad_decimate: f32,
    pub quad_sigma: f32,
    pub refine_edges: ::std::os::raw::c_int,
    pub decode_sharpening: f64,
    pub debug: ::std::os::raw::c_int,
    pub qtp: apriltag_quad_thresh_params,
    #[doc = ""]
    pub tp: *mut timeprofile_t,
    pub nedges: u32,
    pub nsegments: u32,
    pub nquads: u32,
    pub tag_families: *mut zarray_t,
    pub wp: *mut workerpool_t,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_apriltag_detector() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_detector>(),
        136usize,
        concat!("Size of: ", stringify!(apriltag_detector))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detector>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nthreads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nthreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).quad_decimate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_decimate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).quad_sigma as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(quad_sigma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).refine_edges as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(refine_edges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_detector>())).decode_sharpening as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(decode_sharpening)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).debug as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).qtp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(qtp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).tp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nedges as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nsegments as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nsegments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).nquads as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(nquads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).tag_families as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(tag_families)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).wp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(wp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detector>())).mutex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detector),
            "::",
            stringify!(mutex)
        )
    );
}
pub type apriltag_detection_t = apriltag_detection;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct apriltag_detection {
    pub family: *mut apriltag_family_t,
    pub id: ::std::os::raw::c_int,
    pub hamming: ::std::os::raw::c_int,
    pub decision_margin: f32,
    pub H: *mut matd_t,
    pub c: [f64; 2usize],
    pub p: [[f64; 2usize]; 4usize],
}
#[test]
fn bindgen_test_layout_apriltag_detection() {
    assert_eq!(
        ::std::mem::size_of::<apriltag_detection>(),
        112usize,
        concat!("Size of: ", stringify!(apriltag_detection))
    );
    assert_eq!(
        ::std::mem::align_of::<apriltag_detection>(),
        8usize,
        concat!("Alignment of ", stringify!(apriltag_detection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).hamming as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(hamming)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apriltag_detection>())).decision_margin as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(decision_margin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).H as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).c as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apriltag_detection>())).p as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(apriltag_detection),
            "::",
            stringify!(p)
        )
    );
}
extern "C" {
    pub fn apriltag_detector_create() -> *mut apriltag_detector_t;
}
extern "C" {
    pub fn apriltag_detector_add_family_bits(
        td: *mut apriltag_detector_t,
        fam: *mut apriltag_family_t,
        bits_corrected: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn apriltag_detector_clear_families(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_destroy(td: *mut apriltag_detector_t);
}
extern "C" {
    pub fn apriltag_detector_detect(
        td: *mut apriltag_detector_t,
        im_orig: *mut image_u8_t,
    ) -> *mut zarray_t;
}
extern "C" {
    pub fn apriltag_detections_destroy(detections: *mut zarray_t);
}
extern "C" {
    pub fn tag16h5_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag16h5_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag25h9_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag25h9_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tag36h11_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tag36h11_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle21h7_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle21h7_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCircle49h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCircle49h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagCustom48h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagCustom48h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard41h12_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard41h12_destroy(tf: *mut apriltag_family_t);
}
extern "C" {
    pub fn tagStandard52h13_create() -> *mut apriltag_family_t;
}
extern "C" {
    pub fn tagStandard52h13_destroy(tf: *mut apriltag_family_t);
}
